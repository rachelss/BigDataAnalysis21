---
title: "Intro to R tutorial with Australia Fires Data"
author: "Rachel Schwartz"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup

See this [introduction to R](https://datacarpentry.org/R-ecology-lesson/00-before-we-start.html) before continuing the lesson below.

Note that this lesson is adapted from the [Data Carpentry Ecology Lesson](https://datacarpentry.org/R-ecology-lesson/index.html). You can find a lot more information there. Text that has been copied from this lesson is highlighted in blue.

```{r pack, warning=FALSE}
#install.packages("tidyverse")
library(tidyverse)
```

## Get the Data

The data used for this less is all about Australia, including its climate over time and recent fires. To learn more about Australia's devastating fires check out this NY Times [article](https://www.nytimes.com/interactive/2020/01/02/climate/australia-fires-map.html). The data and information comes from Tidy Tuesday, a weekly data project aimed at the R ecosystem. You can find more datasets at https://github.com/rfordatascience/tidytuesday . 

The data are available online so the first thing we'll do is load them into R.
To load data you'll need to use a *function*.

<p style="color:blue">
Functions are "canned scripts" that automate more complicated sets of commands
including operations assignments, etc. Many functions are predefined, or can be
made available by importing R *packages*. A function
usually takes one or more inputs called *arguments*. Functions often (but not
always) return a *value*. A typical example would be the function `sqrt()`. The
input (the argument) must be a number, and the return value (in fact, the
output) is the square root of that number. Executing a function ('running it')
is called *calling* the function.
</p>

<p style="color:blue">
Packages in R are basically sets of additional functions that let you do more
stuff. The functions we've been using so far, like `str()` or `data.frame()`,
come built into R; packages give you access to more of them. Before you use a
package for the first time you need to install it on your machine, and then you
should import it in every subsequent R session when you need it. You should
already have installed the **`tidyverse`** package. This is an
"umbrella-package" that installs several packages useful for data analysis which
work together well such as **`tidyr`**, **`dplyr`**, **`ggplot2`**, **`tibble`**, etc.
</p>

We'll read in our data using the `read_csv()` function, from the tidyverse package **`readr`**.
We assign each dataset to a variable so we can reuse it.
The name of the variable is on the left side of the arrow.
The action we're doing with the function is on the right side.

```{r data}
rainfall <- read_csv('https://tinyurl.com/Oz-fire-rain')
temperature <- read_csv('https://tinyurl.com/Oz-fire-temp')
```

You can see some information about the data we have just loaded.
The name of each column is shown along with the type of data in that column.
The data are stored in a format we call a data frame.

<p style="color:blue">
Data frames are the _de facto_ data structure for most tabular data, and what we
use for statistics and plotting. A data frame can be created by hand, but most commonly they are generated by the functions such as `read_csv()`; in other words, when importing
spreadsheets from your hard drive (or the web). A data frame is the representation of data in the format of a table where the columns are vectors that all have the same length. Because columns are vectors, each column must contain a single type of data (e.g., characters, integers, factors).
</p>

<p style="color:blue">
You will see the message `Parsed with column specification`, followed by each column name and its data type. When you execute `read_csv` on a data file, it looks through the first 1000 rows of each column and guesses the data type for each column as it reads it into R. For example, in this dataset, `read_csv` reads columns as `col_double` (a numeric data type), and as `col_character`. You have the option to specify the data type for a column manually by using the `col_types` argument in `read_csv`.
</p>

<p style="color:blue">
If you want to inspect your data frame there are several functions to do so. `head()` and `str()` can be useful to check the content and the structure of a data frame. Here is a non-exhaustive list of functions to get a sense of the content/structure of the data.
</p>

* Size:
    * `dim(surveys)` - returns a vector with the number of rows in the first element,
          and the number of columns as the second element (the **dim**ensions of
          the object)
    * `nrow(surveys)` - returns the number of rows
    * `ncol(surveys)` - returns the number of columns
* Content:
    * `head(surveys)` - shows the first 6 rows
    * `tail(surveys)` - shows the last 6 rows
* Names:
    * `names(surveys)` - returns the column names (synonym of `colnames()` for `data.frame`
	   objects)
    * `rownames(surveys)` - returns the row names
* Summary:
    * `str(surveys)` - structure of the object and information about the class, length and
	   content of  each column
    * `summary(surveys)` - summary statistics for each column

For more details on this dataset see the [Tidy Tuesday site](https://github.com/rfordatascience/tidytuesday/tree/master/data/2020/2020-01-07).

<p style="color:blue">
This statement doesn’t produce any output because assignments don’t display anything. 
If we want to check that our data has been loaded, we can see the contents of the data frame by typing its name:`rainfall`.
</p>

```{r d2}
rainfall
```

You can also view the data in a separate window by clicking on its name in the Global Environment window.
Here you can also see some information about the data. Note how much data we have!
Click the arrow next to `rainfall` to view the columns and type of data in each column.
For more information about this dataset (i.e.\ the metadata) see [https://github.com/rfordatascience/tidytuesday/blob/master/data/2020/2020-01-07/readme.md](https://github.com/rfordatascience/tidytuesday/blob/master/data/2020/2020-01-07/readme.md)

Note that we've read our data from a website, but you can read local files as well.
These files are in csv format, which means plain text where columns are separated by commas.
This is a very simple format that avoids all the complexity of Excel.
If you need to read an Excel file you can either export as a csv or use a different function to read the data.

For more information on data frames see the [Starting with Data](https://datacarpentry.org/R-ecology-lesson/02-starting-with-data.html#what_are_data_frames) section of the Data Carpentry lesson.

## Basic data exploration

One handy way to look at your data is to get a summary table.
Let's do this for the temperature dataset.

```{r}
summary(temperature)
```

For a really basic exploratory analysis let's look at how temperature is changing in Australian cities over time.
I've summarized our original dataset so you can make your first plot more easily.
First: load the summary data, which can be found at **https://tinyurl.com/Oz-mean-temp**.

```{r t}
#Challenge: load data
yearly_temp <- read_csv('https://tinyurl.com/Oz-mean-temp')
```

Now we'll plot the temperature as a function of time.

### Plotting with **`ggplot2`**

<p style="color:blue">
**`ggplot2`** is a plotting package that makes it simple to create complex plots
from data in a data frame. It provides a more programmatic interface for
specifying what variables to plot, how they are displayed, and general visual
properties. Therefore, we only need minimal changes if the underlying data change
or if we decide to change from a bar plot to a scatter plot. This helps in creating
publication quality plots with minimal amounts of adjustments and tweaking.<br><br>
**`ggplot2`** functions like data in the 'long' format, i.e., a column for every dimension,
and a row for every observation. Well-structured data will save you lots of time
when making figures with **`ggplot2`**<br><br>
ggplot graphics are built step by step by adding new elements. Adding layers in
this fashion allows for extensive flexibility and customization of plots.<br><br>
To build a ggplot, we will use the following basic template that can be used for different types of plots:
</p>

```
ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()
```
<p style="color:blue">
Use the `ggplot()` function and bind the plot to a specific data frame using the
      `data` argument
      </p>

```{r}
ggplot(data = yearly_temp)
```

<p style="color:blue">
Define a mapping (using the aesthetic (`aes`) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc.
</p>

```{r t2a}
ggplot(yearly_temp, aes(year,temperature))
```

<p style="color:blue">
Add 'geoms' – graphical representations of the data in the plot (points,
  lines, bars). **`ggplot2`** offers many different geoms; we will use some 
  common ones today, including:
  
  * `geom_point()` for scatter plots, dot plots, etc.
  * `geom_boxplot()` for, well, boxplots!
  * `geom_line()` for trend lines, time series, etc.  
  </p>

<p style="color:blue">
To add a geom to the plot use the `+` operator. Because we have two continuous variables,
let's use `geom_point()` first:
</p>

```{r t2}
ggplot(yearly_temp, aes(year,temperature)) +
  geom_point()
```

Notice that you have a lot of data points for each year.
This is because you have a data point on the mean temperature for each city.
Let's change our plot to show each city in a different color.

```{r t3}
ggplot(yearly_temp, aes(year,temperature, color = city_name)) +
  geom_point()
```

That's a bit clearer.
Let's show the pattern over time by adding lines between the yearly points.
```{r t4}
ggplot(yearly_temp, aes(year,temperature, color = city_name)) +
  geom_point()+geom_line()
```

And let's tidy this into a publication-quality plot.
```{r t5}
ggplot(yearly_temp, aes(year,temperature, color = city_name)) +
  geom_line() +
  labs(x = "Year", y = "Mean Temperature (Celsius)", color = "") +
  theme_bw()
```

In a few quick commands we can already plot temperature and observe how it's been increasing.

**Notes**

<span style="color: blue">
- Anything you put in the `ggplot()` function can be seen by any geom layers that you add (i.e., these are universal plot settings). This includes the x- and y-axis mapping you set up in `aes()`.<br>
- You can also specify mappings for a given geom independently of the mappings defined globally in the `ggplot()` function.<br>
- The `+` sign used to add new layers must be placed at the end of the line containing the *previous* layer. If, instead, the `+` sign is added at the beginning of the line containing the new layer, **`ggplot2`** will not add the new layer and will return an error message.
</span>

## Manipulating data

In the prior section I gave you a summary table of temperature data.
Let's consider how you could generate this summary table and do other data manipulation
given our original datasets.

<p style="color:blue">
### Data Manipulation using **`dplyr`** and **`tidyr`**

The **`tidyverse`** package tries to address 3 common issues that arise when
doing data analysis with some of the functions that come with R:

1. The results from a base R function sometimes depend on the type of data.
2. Using R expressions in a non standard way, which can be confusing for new
   learners.
3. Hidden arguments, having default operations that new learners are not aware
   of.
   
The package **`dplyr`** provides easy tools for the most common data manipulation
tasks. It is built to work directly with data frames, with many common tasks
optimized by being written in a compiled language (C++). An additional feature is the
ability to work directly with data stored in an external database. The benefits of
doing this are that the data can be managed natively in a relational database,
queries can be conducted on that database, and only the results of the query are
returned.

This addresses a common problem with R in that all operations are conducted
in-memory and thus the amount of data you can work with is limited by available
memory. The database connections essentially remove that limitation in that you
can connect to a database of many hundreds of GB, conduct queries on it directly, and pull
back into R only what you need for analysis.

The package **`tidyr`** addresses the common problem of wanting to reshape your data for plotting and use by different R functions. Sometimes we want data sets where we have one row per measurement. Sometimes we want a data frame where each measurement type has its own column, and rows are instead more aggregated groups - like plots or aquaria. Moving back and forth between these formats is non-trivial, and **`tidyr`** gives you tools for this and more sophisticated data manipulation.

To learn more about **`dplyr`** and **`tidyr`**, you may want to check out this
[handy data transformation with **`dplyr`** cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf) and this [one about **`tidyr`**](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf).

We're going to learn some of the most common **`dplyr`** functions:

- `select()`: subset columns
- `filter()`: subset rows on conditions
- `mutate()`: create new columns by using information from other columns
- `group_by()` and `summarize()`: create summary statistics on grouped data
- `arrange()`: sort results
- `count()`: count discrete values

### Selecting columns and filtering rows

To choose rows based on a specific criterion, use `filter()`.
</p>

For our data let's speculate that we may be seeing an increase in fires due to 
changes in maximum daily temperatures.
After all, it could be spiking temperatures that allow fires to occur,
and that wouldn't be reflected well in the mean temperature for a day.
In this case we need to filter our data to include only data where the column
`temp_type` is listed as max.

```{r f}
temperatures_maxs <- filter(temperature,temp_type == "max")
```

Now consider what summary information you want.
You probably want the average maximum temperature for each city for each year
to look at changes over time.
Let's look at how we would calculate the average maximum temperature for one city for one year.
Then we'll be able to extend this to all cities and all years. 

First filter your data to include only data from 2019 at "PERTH AIRPORT".
This is a challenge for you.

```{r f1}
temperatures_maxs_PerthAir <- filter(temperatures_maxs,site_name == "PERTH AIRPORT")

```

You should have gotten stuck on how we know whether data came from 2019.
That information is in the date column but you have to extract it.
This is a great lesson.
You first need to think about what you want your data to look like.
Once you know what you want you can figure out how to communicate that to the computer.

In this case we'll use the `lubridate` package to process date information.

Challenge: load the lubridate library.

```{r pack2, warning=FALSE}
library(lubridate)
```

You can use the `year` function to extract the year from the date column.
Assign that to a new column in your data frame.

```{r d}
temperatures_maxs_PerthAir$year <- year(temperatures_maxs_PerthAir$date)
```

Now you can filter for data from 2019.
This is a challenge.

```{r f2}
temperatures_maxs_PerthAir_2019 <- filter(temperatures_maxs_PerthAir,year == 2019)
```

Now you can calculate the mean max temperature for this site in this year using the mean
function. This is a challenge.

```{r m}
mean(temperatures_maxs_PerthAir_2019$temperature)
```

<p style="color:blue">

Lubridate is a great package for converting dates in various formats.
For example you might have a date written in a column as 2012.03.26.
You can let the computer know this is a date, and not just a string of characters,
using `lubridate`'s `ymd` (which stands for year month day)
Note that I have given the date as year-month-day and not 
day-month-year or month-day-year.
If you label the rows in your dataset (or your data files) as year-month-day
then when you sort them they'll be in chronological order 
(rather than having all the January datapoints at the top of your spreadsheet or file list).
However, if your dates are in another order you can use the `dmy` or `mdy` functions to
tell R what the date is.
Note that you can use any (or even no separator) between the year, month, and day.

```{r date1}
x <- ymd("2012.03.26")
year(x)
```

### Pipes

What if you want to do multiple filter steps at the same time? There are three
ways to do this: use intermediate steps, nested functions, or pipes.

You probably took the intermediate step approach in your prior work.

This is readable, but can clutter up your workspace with lots of objects that you have to name individually. With multiple steps, that can be hard to keep track of.

You can also nest functions (i.e. one function inside of another), like this:

```{r}
temperatures_maxs$year <- year(temperatures_maxs$date)
temperatures_maxs_PerthAir_2019 <- filter(filter(temperatures_maxs,site_name == "PERTH AIRPORT"),year == 2019)
```
This is handy, but can be difficult to read if too many functions are nested, as
R evaluates the expression from the inside out (in this case, filtering, then selecting).

The last option, *pipes*, let you take
the output of one function and send it directly to the next, which is useful
when you need to do many things to the same dataset.  Pipes in R look like
`%>%` and are made available via the **`magrittr`** package, installed automatically
with **`dplyr`**. 
</p>

```{r}
temperatures_maxs_PerthAir_2019 <- temperatures_maxs %>%
  filter(site_name == "PERTH AIRPORT") %>%
  filter(year == 2019)
```

Note that the data are sent from one function to the next so in subsequent functions
you do not provide the name of the data.
Make sure to put the pipe at the end of the line when using multiple lines so the processing
doesn't end prematurely.

<p style="color:blue">
Some may find it helpful to read the pipe like the word "then". For instance,
in the above example, we took the data frame `temperatures_max`, *then* we `filter`ed
for rows with `site_name == "PERTH AIRPORT"`, *then* we `filter`ed
for rows with `year == 2019`.
Make sure to use the double equals sign when checking for equality.
A single equals will assign data to a variable.

We can even go from the raw data to the mean all in one step.
```{r }
temperature %>%
  filter(temp_type == "max") %>%
  filter(site_name == "PERTH AIRPORT")
```

These are the first few steps but now we realize that we don't have a `year` column in our 
original dataset.
Accessing columns the way we did before doesn't work great with pipe.
Instead we'll use the `mutate` function to add a year column.
Similarly we realize that to calculate the mean we need to access the temperature column.
We'll use `pull` to pull out this column.
Then we can pipe that data to the `mean` function.

```{r }
temperature %>%
  filter(temp_type == "max") %>%
  filter(site_name == "PERTH AIRPORT") %>%
  mutate(year = year(date)) %>%
  filter(year == 2019) %>%
  pull(temperature) %>%
  mean()
```

### Split-apply-combine data analysis and the `summarize()` function

Now we know how to calculate one example, but we would like the mean max temperature
for all cities for all years.
To get this information we'll generate a summary table.

<p style="color:blue">
Many data analysis tasks can be approached using the *split-apply-combine*
paradigm: split the data into groups, apply some analysis to each group, and
then combine the results. **`dplyr`** makes this very easy through the use of the
`group_by()` function.

#### The `summarize()` function

`group_by()` is often used together with `summarize()`, which collapses each
group into a single-row summary of that group.  `group_by()` takes as arguments
the column names that contain the **categorical** variables for which you want
to calculate the summary statistics. 
</p>

In this case we are interested in one result for each city for each year.
That means we'll group by these variables.
Then we'll generate a summary table.
In this table we want to calculate the mean of the temperature for each group.

```{r}
mean_max_temp <- temperatures_maxs %>%
  group_by(city_name,year) %>%
  summarize(mean_max_temp = mean(temperature))
```

If you look at your results you'll see some NA's in your results.
Because there were NAs in your original data, you are averaging real data
with NA and producing NA.
To avoid this, filter out cases where temperature is given as NA.
We check for NAs using the `is.na` function and check for cases
where it's not NA using `!is.na` where the `!` means not so `!is.na` means
"is not NA".

```{r}
mean_max_temp <- temperatures_maxs %>%
  filter(!is.na(temperature)) %>%
  group_by(city_name,year) %>%
  summarize(mean_max_temp = mean(temperature))
```

Now you can plot mean_max_temp as a function of year. This is a challenge.
Don't forget to fix your axis labels.

```{r}
ggplot(mean_max_temp, aes(year, mean_max_temp,color=city_name)) +
         geom_line()+
  labs(x = "Year", y = "Mean Temperature (Celsius)", color = "") +
  theme_bw()
```

You can see a couple of things about this plot that could be improved.
First we could use more labels on the x axis so we can more easily see which year we're looking at.
We add the layer `scale_x_continuous` for continous data on the x axis.
We specify where we want our axis to break using the `breaks` argument.
We set this equal to the list of breaks we want using `c` for our list.

```{r}
ggplot(yearly_temp, aes(year,temperature, color = city_name)) +
  geom_line() +
  labs(x = "Year", y = "Mean Temperature (Celsius)", color = "") +
  theme_bw() +
  scale_x_continuous(breaks = c(1910, 1930, 1950, 1970, 1990, 2010))
```

Now consider that it's more visually appealing to get the city labels to be in the same order
as the lines. We want to make it easy to match each city to its position on the graph.
To do this we need to reorder the cities based on their final data point (i.e. the temperature in 2019).

Take the `yearly_temp` data frame and filter it for 2019.
Then `arrange` the data frame based on the values in the temperature column.
Then `pull` out just the names of the cities (now in the correct order).

```{r}
labels <- yearly_temp %>% filter(year == 2019) %>% 
  arrange(desc(temperature)) %>% pull(city_name)
```

Now we can use this list of cities as the ordering in our legend.
We add a layer to our plot with the `scale_color_discrete` function (as we are looking at the colors and they are discrete rather than continuous data).
We specify that both breaks (i.e. our legend colors) and labels (i.e. the city names are given by the `labels` variable.

```{r}
ggplot(yearly_temp, aes(year,temperature, color = city_name)) +
  geom_line() +
  labs(x = "Year", y = "Mean Temperature (Celsius)", color = "") +
  theme_bw() +
  scale_x_continuous(breaks = c(1910, 1930, 1950, 1970, 1990, 2010)) +
  scale_color_discrete(breaks = labels, labels = labels)
```

For more information on these visual tricks see [Claus Wilke's Data Visualization book](https://serialmentor.com/dataviz/redundant-coding.html). 

## Tidy data

Note that we have lots of data but it's a bit hard to compare in the table.
That's because when we work with data in R we typically use "long form".
That means for everyone combination of variables (year and city),
we have one observation (mean temp).
Humans typically like to see data in "wide form".
That means you (or a colleague) probably collected data like this example.

```{r}
temps_across_cities <- read_csv("https://tinyurl.com/Oz-temp-across-cities")
head(temps_across_cities)
```

Seeing the data like this makes comparisons much easier but it's harder to plot or summarize
in the way we've been doing.
To work with the data the way we've been doing we need to have just one observation per row.
We use the `pivot_longer` functions and specify the columns that include our observations.
In this case it is the columns that are labeled with site names and contain temperature measurements.
This means we will leave date and temp_type columns
and make new columns labeled site and temperature.
We then specify two column names: (1) the names that come from the column names will go into a column named site; (2) the second column will contain the temperature values.

```{r}
temps_long <- temps_across_cities %>%
  pivot_longer("PERTH AIRPORT":"MELBOURNE (OLYMPIC PARK)", 
               names_to = "site", values_to = "temp")
```

This gives us four columns: date, temp_type, site, and temp, with one observation per row.

Challenge: try this with a rainfall dataset.

```{r}
rain_across_cities <- read_csv("https://tinyurl.com/Oz-rain-across-cities")
```

Before you pivot your data notice the errors when it read it.
If you didn't catch the errors when you read the data,
take a look at the structure of your data frame by clicking on the arrow next to the 
variable in the Environment.
Or use the structure function `str`.

```{r}
str(rain_across_cities)
```

There are a couple of ways to deal with this, but we'll fix it by having R check more
lines before deciding on the column type.

```{r}
rain_across_cities <- read_csv("https://tinyurl.com/Oz-rain-across-cities",
                               guess_max = 10000)
```

Now each column looks like it was read as the correct type.
Now you can pivot your data.

```{r}
rain_long <- rain_across_cities %>%
  pivot_longer(4:10, 
               names_to = "site", values_to = "temp")
```

If you want to share your summary table
you might want to convert to wide format to make it more human readable.
We use `pivot_wider` and specify that the new column names come from
the current `city_name` column and the values for all of the new columns
come from the `mean_max_temp` column.

```{r}
mean_max_temp_wide <- mean_max_temp %>%
  pivot_wider(names_from = city_name, values_from = mean_max_temp)
```

Click on the data in the Environment to see it.

You can save your new human-readable data.

```{r}
write_csv(mean_max_temp_wide, path = "data/mean_max_temp_wide.csv")
```

There are a lot of complex ways to rearrange columns using the pivot functions.
For example, if we want to pivot our rainfall data into wide format,
we realize that we have multiple pieces of information tied to one observation.
When we pivot to make the column names as the location we will have multiple
observations per row.
You can think of the rows and columns as axes,
and information like period is now an extra axis that doesn't fit well.
For example,
we can only set the column names as either coming from station_code OR city_name OR station name.
Thus, when we pivot we can specify which columns to keep by listing them.

```{r}
rain_wide <-rainfall %>% pivot_wider(c(year,month,day),
                         names_from = "station_name", values_from = rainfall)
```

We can also aggregate data on the fly.
Think about what you need to do to generate a data frame
where each row contains the sum of rainfall for the year at each station.
When we pivot the data we want to just leave the year.
However, if we get values from the rainfall column we'll end up with a list of values
in each cell (i.e. for each year-station_name combinations there's a list of values).
Therefore, in addition to pivoting in this way we need to specify that we want to sum this list.

```{r}
rainfall %>% filter(!is.na(rainfall)) %>% pivot_wider(year,
                         names_from = station_name, 
                         values_from = rainfall,
                         values_fn = list(rainfall = sum))
```

To get around needing multiple pieces of information per observation,
two variables are sometimes stored in the column name of a wide dataset.
You can see why we prefer long data.
This dataset has both city name and station code in each column name.
This allows for observations in different stations in each city.
However if we want to get data from all stations in the city we need these two pieces of information separately.

```{r}
rain_across_stations <- read_csv("https://tinyurl.com/Oz-rain-across-stations",
                               guess_max = 10000)
rain_across_stations %>% pivot_longer(
  cols = Perth_009151:Melbourne_086232,
  names_to = c("city", "station"), 
  names_pattern = "(.*)_(.*)",
  values_to = "rainfall"
)
```

This is a bit more elaborate than before.
First we specify the range of columns to rearrange (this is the same as before).
This time we want to break each column name in two.
We now specify a list of columns in the names_to argument.
Now we need to specify how to break the column name.
We break the name at the underscore - you can see that in the middle.
On each side of the underscore we specify the pattern of the name.
In this case it can be any number of any character.
We specify the latter with `.` and follow that with the `*` to specify multiple.

For more complex pivoting look at the Pivoting vignette on the tidyr page of the tidyverse website.

## More data manipulation

Another analysis we might be interested in is whether temperatures for individual months are increasing.

Challenge: Examine how the temperature has increased over time in Canberra. Filter for data from Canberra. Get the average max temperature in each month for each year. Pivot year to be viewable.

First extract the month from the date information.
Then filter for just maximum temperatures in Canberra.
Then generate a summary table including the average temperature for each month-year combination.
Then pivot this data so that each month is a row and you can view changes in temperature over the years
by scrolling through columns.

```{r}
monthly_temps_CAN <- temperature %>%
  filter(!is.na(temperature)) %>%
  mutate(year = year(date), month = month(date)) %>%
  filter(city_name == "CANBERRA") %>%
  filter(temp_type == "max") %>%
  group_by(month, year) %>%
  summarize(avg_temp = mean(temperature)) %>%
  pivot_wider(names_from = year, values_from = avg_temp)
head(monthly_temps_CAN)

```

Now we can summarize by month and plot.

```{r}
monthly_temps <- temperature %>%
  filter(!is.na(temperature)) %>%
  mutate(year = year(date), month = month(date)) %>%
  group_by(month, year) %>%
  summarize(avg_temp = mean(temperature)) 

ggplot(monthly_temps, aes(month, avg_temp, group=year, color=year)) +
  geom_line() + geom_point()
```

Did you notice that the color is along a scale?
For R, year is a continuous variable so the scale is continuous.
This probably isn't what you want.
You might view year as a factor to separate the years distincly.

```{r}
ggplot(monthly_temps, aes(month, avg_temp, group=year, color=factor(year))) +
  geom_line() + geom_point()
```

On the other hand, although you can see lighter colors mostly at the top, all those data are really messy anyway.
There are really too many categories for a discrete variable.
Let's try grouping the information by before and after 1964 to make things simpler.
We have already seen `mutate` to add a column.
This time we want to add a column that designates whether the date is before
or after 1964 using 0 or 1.
We use the `ifelse` function to do this.
Then we take this updated dataframe and group by both month and time period
and summarize the average temperature for each group.

```{r}
monthly_temps_by_period <- temperature %>%
  filter(!is.na(temperature)) %>%
  mutate(year = year(date), month = month(date)) %>%
  mutate(time_period = ifelse( year <= 1964, 0, 1)) %>%
  group_by(month, time_period) %>%
  summarize(avg_temp = mean(temperature)) 
```

Now we can plot the result.
The x-axis is month (notice we've added the month function so this looks like a date).
The y-axis is the temperature.
And we have separate lines for our two time periods.

```{r}
ggplot(monthly_temps_by_period, aes(month(month, label = T), avg_temp, 
                                    group=time_period, col=factor(time_period))) +
  geom_line() + geom_point() +
  scale_color_discrete(name = "", labels = c("Before 1964", "After 1964")) +
  labs(y = "Average Temperature (°C)",
       x = "Month") 

```

What do you observe about how monthly temperatures differ?

Save your plot!

```{r, eval=FALSE}
ggsave('avg_monthly_temps.png')
```

We can also look at cities separately.
Notice that I've redone my grouping for my summary table to include city.
Notice the `facet_wrap` function here to automatically create separate plots.

```{r}
monthly_temps_by_period <- temperature %>%
  filter(!is.na(temperature)) %>%
  mutate(year = year(date), month = month(date)) %>%
  mutate(time_period = ifelse( year <= 1964, 0, 1)) %>%
  group_by(month, time_period, city_name) %>%
  summarize(avg_temp = mean(temperature, na.rm = T)) 

ggplot(monthly_temps_by_period, aes(month(month, label = T), avg_temp, 
                                    group=time_period, col=factor(time_period))) +
  geom_line() + geom_point() + facet_wrap(~city_name) +
  scale_color_discrete(name = "", labels = c("Before 1964", "After 1964")) +
  labs(y = "Average Temperature (°C)",
       x = "Month") 
```

## Joining data together

We have separate datasets for rainfall and temperature.
What if we want to know the relationship between these variables.
We need to get these data into a single dataframe.
First think about how the data line up.
We need to know that KENT (in the temperature data frame) is the same location
as Adelaide (in the rainfall dataframe).


```{r}
city_convert <- c("Perth","X","Adelaide","Brisbane","Sydney", "Canberra", "Melbourne")
names(city_convert) <- unique(temperature$city_name)
temperature <- temperature %>% 
  mutate(city = recode(city_name,!!!as.list(city_convert)))
```

We need to think about how our dates don't match (yet).
We have two measurements for rain in Brisbane so we should probably average those.
This will give us six cities and one measurement per city.

```{r}
rain2 <- rainfall %>%
  filter(!is.na(rainfall)) %>%
  mutate(date = ymd(paste(year,month,day))) %>%
  select(city_name,date,rainfall) %>%
  group_by(city_name,date) %>%
  summarize(rainfall = mean(rainfall))
```

Now we can join the datasets together.
For any given date in any given city we now have temperature and rainfall side-by-side.

```{r}
rain_plus_temp <- left_join(rain2,
                            filter(
                              select(temperature,date,temperature,temp_type,city),
                              temp_type == "max"),
          by=c("date",c("city_name" = "city")))
```

```{r, include=FALSE}
rain_plus_temp <- mutate(rain_plus_temp, month = month(date),
                         season = case_when(month > 2 & month < 6 ~ "fall",
                                            month > 5 & month < 9 ~ "winter",
                                            month > 8 & month < 12 ~ "spring",
                                            month == 12 | month < 3 ~ "summer"))

ggplot(rain_plus_temp,aes(temperature,rainfall)) +
  geom_point() + facet_wrap(~season)
```

```{r, include=FALSE}
rain_plus_temp %>% mutate(year = year(date)) %>%
  group_by(city_name,month,year) %>%
  summarize(rain = sum(rainfall), temp = mean(temperature,na.rm = TRUE)) %>%
  ggplot(aes(temp,rain,color=year,group=year)) + geom_point() +
    geom_smooth(method="lm", se = FALSE)

```



